# *RISC-V Platform-Level Interrupt Controller Specification*

## Copyright and license information

This RISC-V PLIC specification is

[%hardbreaks]
(C) 2017 Drew Barbier <drew@sifive.com>
(C) 2018-2019 Palmer Dabbelt <palmer@sifive.com>

It is licensed under the Creative Commons Attribution 4.0 International
License (CC-BY 4.0).  The full license text is available at
https://creativecommons.org/licenses/by/4.0/.

## Introduction

This document contains the RISC-V platform-level interrupt controller (PLIC)
specification, which defines an interrupt controller specifically designed to
work in the context of RISC-V systems.  The PLIC multiplexes various device
interrupts onto the external interrupt lines of various Hart contexts, with
hardware support for interrupt priorities. +
This specification defines the general PLIC architecture and operation parameters.
However, the PLICv1 spec-out here is the RISC-V Platform Level Interrupt
Controller which is commonly using on RISC-V platforms currently.

## The RISC-V PLICv1

RISC-V PLICv1 is the first version of RISC-V platform-level interrupt controller 
which simply defines the operation parameters for configuring the characteristics
of external interrupts and handling external interrupt events. Besides of the base
address of PLIC memory-mapped registers which is platform-specific implementation,
the control registers of PLIC are designed to locate at the fixed offset within
memory-mapped region. The characteristics of PLIC operation parameters are fixed as
well. The PLIC which claimed as PLICv1-Compliant should follow the implementations
mentioned in below sections.

image::https://github.com/changab/riscv-plic-acpi-images/blob/master/PLIC.jpg[GitHub][1000,643]

#### Figure 1 RISC-V PLIC Interrupt Architecture Block Diagram

## RISC-V PLIC Operation Parameters

Six PLIC operation parameter register blocks are standardized in this spec, those are: +

- *Interrupt Priorities registers:* +
   The interrupt priority for each interrupt source. +

- *Interrupt Pending Bits registers:* +
   The interrupt pending status of each interrupt source. +
   
- *Interrupt Enables registers:* +
   The enablement of interrupt source. +

- *Priority Thresholds registers:* +
   The interrupt priority threshold. +

- *Interrupt Claim registers:* +
   The register to acquire interrupt source ID. +
   
- *Interrupt Completion registers:* +
   The register to send interrupt completion message to the associated gateway. +
+

Below is the figure of PLIC Operation Parameter Block Diagram,

image::https://github.com/changab/riscv-plic-acpi-images/blob/master/PLICArch.jpg[GitHub]

#### Figure 2 PLIC Operation Parameter Block Diagram

## Memory Map

The `base address of PLIC Memory Map` is platform implementation-specific.

*PLICv1-Compliant Memory Map*

	base + 0x000000: Reserved (interrupt source 0 does not exist)
	base + 0x000004: Interrupt source 1 priority
	base + 0x000008: Interrupt source 2 priority
	...
	base + 0x000FFC: Interrupt source 1023 priority
	base + 0x001000: Interrupt Pending bit 0-31
	base + 0x00101F: Interrupt Pending bit 992-1023
	...	
	base + 0x002000: Enable bits for sources 0-31 on context 0
	base + 0x002004: Enable bits for sources 32-63 on context 0
	...
	base + 0x00207F: Enable bits for sources 992-1023 on context 0
	base + 0x002080: Enable bits for sources 0-31 on context 1
	base + 0x002084: Enable bits for sources 32-63 on context 1	
	...
	base + 0x0020FF: Enable bits for sources 992-1023 on context 1
	base + 0x002100: Enable bits for sources 0-31 on context 2
	base + 0x002104: Enable bits for sources 32-63 on context 2	
	...
	base + 0x00217F: Enable bits for sources 992-1023 on context 2
	...
	base + 0x1F1F80: Enable bits for sources 0-31 on context 15871
	base + 0x1F1F84: Enable bits for sources 32-63 on context 15871		
	base + 0x1F1FFF: Enable bits for sources 992-1023 on context 15871
	...	
	base + 0x1FFFFC: Reserved
	base + 0x200000: Priority threshold for context 0
	base + 0x200004: Claim/complete for context 0
	base + 0x200008: Reserved
	...
	base + 0x200FFC: Reserved
	base + 0x201000: Priority threshold for context 1
	base + 0x201004: Claim/complete for context 1
	...
	base + 0x3FFE000: Priority threshold for context 15871
	base + 0x3FFE004: Claim/complete for context 15871
	base + 0x3FFE008: Reserved
	...	
	base + 0x3FFFFFC: Reserved
	
Below sections describe the control register blocks of PLIC operation parameters.

## Register Width

The memory map register width is in 32-bit.

## Interrupt Priorities

If PLIC support Interrupt Priorities, then each PLIC interrupt source can be assigned a priority by writing to its `n-bit`
memory-mapped `priority` register.  The `n-bit` indicates the bits which takes from 32-bit length register for configuring Interrupt Source Priority level. The `n-bit` must be the value of power of 2 and less than 32-bit. A priority value of 0 is reserved to mean
''never interrupt'' and effectively disables the interrupt. Priority 1 is the
lowest active priority while the maximun level of priority depends on PLIC implementation. Ties between global interrupts of the same priority
are broken by the Interrupt ID; interrupts with the lowest ID have the highest
effective priority. +

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name*| *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Interrupt Source Priority
|Interrupt Source Priority #0 to #N
| ( (Number of Interrupt Source) / (32 / `n-bit`)) * 4
|This is a continuously memory block which contains PLIC Interrupt Source Priority. Total N Interrupt Source Priority in this memory block. Interrupt Source Priority #0 is reserved which indicates it does not exist. + 
The length of effective bits of each Interrupt Source Priority is PLIC design-specific. The total bits which taken from 32-bit length register for each Interrupt Source Priority maybe larger than the effective bits used by interrupt priority level. + 
`Width of Register` (32-bit) may equal to the bits occupied by Interrupt Source Priority(`n-bit`) or larger than (`n-bit`)
| *Interrupt sources:* 1024 (N=1024) +
  *Bits taken from register:* 32-bit +
  *Bits of Interrupt Source Priority:* 3 bits (n-bit=3, 8 priority levels) +
  *Register Block Address:* 0x000000 +
  *Register Block Size:* 0x1000 +
|===

*PLICv1-Compliant Interrupt Source Priority Memory Map* +

	0x000000: Reserved (interrupt source 0 does not exist)
	0x000004: Interrupt source 1 priority
	0x000008: Interrupt source 2 priority
	...
	0x000FFC: Interrupt source 1023 priority

## Interrupt Pending Bits

The current status of the interrupt source pending bits in the PLIC core can be
read from the pending array, organized as 32-bit register.  The pending bit
for interrupt ID N is stored in bit (N mod 32) of word (N/32).  Bit 0
of word 0, which represents the non-existent interrupt source 0, is hardwired
to zero.

A pending bit in the PLIC core can be cleared by setting the associated enable
bit then performing a claim. +

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name* | *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Interrupt Pending Bits
|Interrupt Pending Bit of Interrupt Source #0 to #N
|(Total number of Interrupt Sources) / 8, which means N / 8 bytes
|This is a continuously memory block contains PLIC Interrupt Pending Bits. Each Interrupt Pending Bit occupies 1-bit from this register block.
| *Interrupt sources:* 1024 (N=1024) +
  *Register Block Address:* 0x001000 +
  *Register Block Size:* 0x20 +
|===

*PLICv1-Compliant Implementation of Interrupt Pending Bits Memory Map* +

	0x001000: Interrupt Source #0 to #31 Pending Bits
	...
	0x00101F: Interrupt Source #992 to #1023 Pending Bits


## Interrupt Enables

Each global interrupt can be enabled by setting the corresponding bit in the
`enables` register. The `enables` registers are accessed as a contiguous array
of 32-bit registers, packed the same way as the `pending` bits. Bit 0 of enable
register 0 represents the non-existent interrupt ID 0 and is hardwired to 0.
PLIC may have multiple Interrupt Enable Bits blocks for the contexts according to
PLIC implementation. The `context` is referred to the specific privilege mode in the
specific Hart of the specific RISC-V processor instance. How PLIC organizes interrupts
for the contexts (Hart and privilege mode) is out of RISC-V PLIC specification scope, 
however it must be spec-out in vendor's PLIC specification.

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name* | *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Interrupt Enable Bits
|Interrupt Enable Bit of Interrupt Source #0 to #N
|Total number of (Interrupt Sources / 8) * (Number of contexts), which means (N / 8) * (Number of contexts) bytes
|This is a continuously memory block contains PLIC Interrupt Enable Bits. Each Interrupt Enable Bit occupies 1-bit from this register block.
| *Interrupt sources:* 1024 (N=1024) +
  *Register Block Address:* 0x002000 +
  *Total Contexts:* 15872 +
  *Register Block Size:* 0x1f0000 +
|===

*PLICv1-Compliant Interrupt Enable Bits Memory Map* +

	0x002000: Interrupt Source #0 to #31 Enable Bits on context 0
	...
	0x00207F: Interrupt Source #992 to #1023 Enable Bits on context 0
	0x002080: Interrupt Source #0 to #31 Enable Bits on context 1
	...
	0x0020FF: Interrupt Source #992 to #1023 Enable Bits on context 1
	0x002100: Interrupt Source #0 to #31 Enable Bits on context 2
	...
	0x00217F: Interrupt Source #992 to #1023 Enable Bits on context 2
	0x002180: Interrupt Source #0 to #31 Enable Bits on context 3
	...
	0x0021FF: Interrupt Source #992 to #1023 Enable Bits on context 3
	...
	...
	...
	0x1F1F80: Interrupt Source #0 to #31 on context 15871	
	...	
	0x1F1F80: Interrupt Source #992 to #1023 on context 15871
	
## Priority Thresholds

If PLIC supports Interrupt Priorities, the PLIC could optionally provide `threshold register`
for the settings of a interrupt priority threshold. The `threshold register` is a WARL field.
The PLIC will mask all PLIC interrupts of a priority less than or equal to `threshold`.  For example,
a`threshold` value of zero permits all interrupts with non-zero priority. +
Priority Thresholds registers are not necessary be organized in continuously. That is PLIC
implementation-specific and out of RISC-V PLIC specification scope, however it must be spec-out
in vendor's PLIC specification. +
 +
*For PLICv1-specific*, Priority Threshold registers are not organized in continuously in memory-mapped region.
Priority Threshold for each context is located at 4K alignement starts from offset 0x200000 as
it delineated in memory map below.

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name* | *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Priority Threshold
|n-bit value of Priority Threshold
|(n-bit + 31)/32) * 4. +
If multiple Priority Threshold registers supported for contexts, the total size is (Number of contexts) times of above if 
Priority Threshold registers are organized in continuously. +

|This is the register of Priority Thresholds setting
| *Interrupt sources:* 1024 (N=1024) +
  *Bits of Interrupt Source Priority:* 3 bits (n-bit=3, 8 priority levels) +
  *Register Block Address:* 0x0200000 +
  *Total Contexts:* 15872 +
|===

*PLICv1-Compliant Interrupt Priority Thresholds Memory Map* +

	0x200000: Priority threshold for context 0
	0x201000: Priority threshold for context 1
	0x202000: Priority threshold for context 2
	0x203000: Priority threshold for context 3
	...
	...
	...
	0x3FFF000: Priority threshold for context 15871
	
## Interrupt Claim Process

The PLIC can perform an interrupt claim by reading the `claim/complete`
register, which returns the ID of the highest priority pending interrupt or
zero if there is no pending interrupt.  A successful claim will also atomically
clear the corresponding pending bit on the interrupt source. +
The PLIC can perform a claim at any time and the claim operation is not affected
by the setting of the priority threshold register. +
The Interrupt Claim Process register are context based and not necessary be organized in continuously.
That is PLIC implementation-specific and out of RISC-V PLIC specification scope, however
it must be spec-out in vendor's PLIC specification. +
 +
*For PLICv1-specific*, Interrupt Claim Process registers are not organized in continuously in memory-mapped region.
Interrupt Claim Process register for each ceach context is located at (4K alignement + 4) starts from offset 0x200000 as
it delineated in memory map below.

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name* | *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Interrupt Claim Process (blocks)
|Interrupt Claim Process register
|4 Bytes +
If multiple Interrupt Claim Process registers is supported and organized continuously, then total size is (Number of contexts) times of above. +
|This is the register used to acquire interrupt ID.
| *Interrupt sources:* 1024 +
  *Register Block Address:* 0x0200004 +
  *Total Contexts:* 15872 +
|===

*PLICv1-Compliant Interrupt Claim Process Memory Map* +

	0x200004: Interrupt Claim Process for context 0
	0x201004: Interrupt Claim Process for context 1
	0x202004: Interrupt Claim Process for context 2
	0x203004: Interrupt Claim Process for context 3
	...
	...
	...
	0x3FFF004: Interrupt Claim Process for context 15871
	
## Interrupt Completion

The PLIC signals it has completed executing an interrupt handler by writing the
interrupt ID it received from the claim to the `claim/complete` register.  The
PLIC does not check whether the completion ID is the same as the last claim ID
for that target.  If the completion ID does not match an interrupt source that
is currently enabled for the target, the completion is silently ignored. +
The Interrupt Completion registers are context based and not necessary be organized in continuously.
That is PLIC implementation-specific and out of RISC-V PLIC specification scope,
however it must be spec-out in vendor's PLIC specification. +
The Interrupt Completion register is the same address as PLIC Interrupt Claim Process hence the read access is for PLIC Interrupt Claim Process,
the write access is for Interrupt Completion. +
 +
*For PLICv1-specific*, Interrupt Completion registers are not organized in continuously in memory-mapped region.
Interrupt Completion register for each context is located at (4K alignement + 4) starts from offset 0x200000 as
it delineated in memory map below.

[cols="10%,15%,20%,25%,30%"]
|===
| *PLIC Register Block Name* | *Registers*|*Register Block Size in Byte*| *Description*| *PLICv1-Compliant Implementation*
|Interrupt Completion (blocks)
|Interrupt Completion register
|4 Bytes  +
If multiple Interrupt Completion registers supported and located continuously, then total size is (Number of contexts) times of above. +
|This is register to write to complete Interrupt process
| *Interrupt sources:* 1024 +
  *Register Block Address:* 0x0200004 +
  *Total Contexts:* 15872 +
|===

*PLICv1-Compliant Interrupt Completion Memory Map* +

	0x200004: Interrupt Completion for context 0
	0x201004: Interrupt Completion for context 1
	0x202004: Interrupt Completion for context 2
	0x203004: Interrupt Completion for context 3
	...
	...
	...
	0x3FFF004: Interrupt Completion for context 15871

---
# *RISC-V PLIC Specification Affinity*

## ACPI Specification: Proposed ACPI Multiple APIC Description Table (MADT) for RISC-V PLIC

### 5.2.12 Multiple APIC Description Table (MADT)
*Table 5-46 Interrupt Controller Structure Types*
|===
| *Value* | *Description*|*_MAT for Processor object*| *_MAT for an I/O APIC object*| *Reference*
|0x10
|RISC-V Platform Level Interrupt Controller (PLIC)
|no
|no
|Section 5.2.12.19
|===
### 5.2.12.19 RISC-V Platform Level Interrupt Controller (PLIC) Structure
PLIC is used as platform global external interrupt controller for RISC-V processor. PLIC can be connected to RISC-V processor and the Harts in the processor according to the platform design. Multiple PLIC structures is possible reported in MDAT for multiple RISC-V physical processor on platform. The Privilege Modes of external interrupt is also configurable. The properties of interrupt event source and settings of PLIC should be configured by system firmware during POST according to the platform design. The settings of PLIC must be reported in MADT PLIC structure by system firmware. ACPI compliant OS can install the corresponding interrupt handler for handling Supervisor Mode external interrupts. In the case if external interrupt is triggered as Machine Mode external interrupt and the Machine Mode external interrupt is not delegated to Supervisor Mode according to ACPI SDEI table, OS will have to register event handler on Machine Mode external interrupt using Supervisor Binary Interface.


*Table 5-67 PLIC Structure*
[cols="35%,10%,10%,45%"]
|===
| *Field* |*Byte Length*|*Byte Offset*| *Description*
|Type
| 1
| 0
| 0x10 PLIC structure

|Length
|1
|1
|28 + n + n * x (See below description)

|PLIC Version
|1
|2
|PLIC version

|Processor UID
|1
|3
|Processor UID, this value matches to _UID value in ACPI processor device object. This also means the processor core index.

|PLIC Base Address
|8
|4
|64-bit physical address of PLIC registers, this also the identifier of PLIC instance.

|Total External Interrupt Sources Supported in this PLIC
|2
|12
|Number of external interrupts supported on this PLIC.

|Number of Harts Connected with PLIC
|1
|14
|Number of Harts which are connected by PLIC. The value declared in this filed is equal to the “n” in next field.

|PLIC Target Hart ID [n]
|n
|15
|An array of Hart ID in which are connected by PLIC.

|Global System Interrupt Vector Base
|2
|15 + n
|Base interrupt number of Global System Interrupt of this PLIC. Refer to section 5.2.13 for Global System Interrupts

|Maximum Interrupt Priority Levels
|1
|16 + n
|Number of interrupt priority levels supported by this PLIC. A value of zero permit all interrupts with non-zero priority. The maximum interrupt priority is 255.

|Starting Offset to Interrupt Source Priority block
|4
|18 + n
|The relative offset to PLIC physical address, which points to interrupt priority block of interrupt sources supported by this PLIC core. Value of zero means no interrupt priority supported in PLIC.

|Length in Bits of each Interrupt Source Priority
|2
|22 + n
|Length in bits of interrupt source priority.

|Starting Offset to Interrupt Pending Bits Block
|4
|24 + n
|The relative offset to PLIC physical address which points to interrupt pending block. Value of zero means no interrupt pending bits supported in PLIC core.
|Number of Hart Context Interrupt Description Structures
|1
|28 + n
|Number of Hart context interrupt structures follow PLIC structure. See *Table 5-68*.

|Hart Context Interrupt Description (HCID) Structures
|n * x
|29 + n
|The first HCID structure. Total length in byte for each HCID is referred as “x”.
|===

*Table 5-68 PLIC HCID Structure*
[cols="35%,10%,10%,45%"]
|===
| *Field* | *Byte Length*|*Byte Offset *| *Description*
|Hart ID
|1
|0
|ID of Hart owns these interrupt sources. The value specified in this field must be one of value in PLIC Target Hart ID [n] in *Table 5-67* PLIC structure.

|Privilege Level
|1
|1
|The privilege levels of this Hart. +
0: User Mode +
1: Supervisor Mode +
2: Reserved +
3: Machine Mode

|Starting Offset to Interrupt Enable Bits Block
|4
|2
|The relative offset to PLIC physical address which points to interrupt enable bits block. Value of zero means no interrupt enable bits supported in PLIC. The interrupt enable bits block is used to enable specific interrupt source for the Hart specified in Hart ID and Privilege Mode specified in Privilege Level in this table (PLIC HCID Structure)

|Offset to the Interrupt Priority Threshold
|4
|6
|The relative offset to PLIC physical address which points to interrupt priority threshold of the Hart specified in Hart ID and Privilege Mode specified in Privilege Level in this table (PLIC HCID Structure). The valid value is in the range of Maximum Interrupt Priority Levels in *Table 5-67 PLIC structure*. The bit length of interrupt priority is specified in Length in Bits of each Interrupt Source Priority in Table *5-67 PLIC structure*.

|Length in Byte of Interrupt Priority Threshold
|10
|1
|The length of Interrupt Priority Threshold register of the Hart specified in Hart ID and Privilege Mode specified in Privilege Level in this table (PLIC HCID Structure)

|Offset to Interrupt Claim/Complete
|4
|10
|The relative offset to PLIC physical address which points to interrupt Claim/Complete register of the Hart specified in Hart ID and Privilege Mode specified in Privilege Level in this table (PLIC HCID Structure).
|===


image::https://github.com/changab/riscv-plic-acpi-images/blob/master/Figure5-24.jpg[GitHub][1000,705]

#### Figure 5.24 PLIC-Global System Interrupts (Single Processor and Single PLIC Scenario)

image::https://github.com/changab/riscv-plic-acpi-images/blob/master/Figure5-25.jpg[GitHub][1000,705]

#### Figure 5.25 PLIC-Global System Interrupts (Multiple Processors and Multiple PLICs Scenario)


## Device Tree Syntax for RISC-V PLICv1

Below sections describe the Device Tree syntax used to delineate the characteristics of RISC-V PLIC

### General Device Tree Syntax for RISC-V PLIC

[cols="25%,20%,35%,15%"]
|===
| *Device Tree Syntax* | *Description* | *Property Type* | *Property Value*
|#interrupt-cells
|Cells required to encode interupt specifier.
|<u32>
|1

|compatible
|The programming model for RISC-V PLIC.
|<string>
|"riscv,plic"

|interrupt-controller
|This is a interrupt controller device.
|<empty>
|N/A

|interrupts-extended
|Interrupts generated by a device with `#interrupts-cells` speciﬁer of 1.
|prop-encoded-array
|Platform-specific

|reg
|RISC-V PLIC memmap address space in <u64> pair.
|<prop-encoded-array>
|Platform-specific

|reg-names
|Supplemental name which is given to RISC-V PLIC memory map resource.
|<string>
|Platform-specific
|===

### RISC-V PLICv1 Specific Binding Device Tree Syntax 

Below additional properties are binded to RISC-V PLIC Device Tree to provide sufficient information to device driver.
`<company>` name is fixed to `riscv` associated with properties defined in below table for RISC-V PLIC.

[cols="25%,20%,35%,15%"]
|===
| *Device Tree Syntax* | *Description* | *Property Type* | *Property Value*
|ndev
|Number of devices connected to this PLIC
|<u32>
|Platform-specific

|int-context
|Interrupt Operation Parameters for the Hart Contexts
|<prop-encoded-array> +
This property describes the interrupt sources on specific RISC-V Hart context.
Multiple `int-context` properties could be declared in PLICv1 Device Tree. If multiple
`int-context` are declared, the secquence of `int-context` must be in the same order
of supported contexts organized in Interuupt Enable block.
Platform vendor shall spec-out the platform-implementation in platform specification. +
 +
*parent-cpu* _<phandle>_ +
The parent CPU node. +
 +
*hart-id:* _<u32>_ +
The Hart ID of this CPU. +
 +
*privilege-mode:* _<string>_ +
The privilege mode of this context. The value could be one of below, +
  "M-Mode", +
  "S-Mode", +
  "U-Mode" +
 +
|Platform-specific

|===
			
### For the platforms the OS image with device driver which well knows the configuration of RISC-V PLICv1:

In this use case, the Device Tree of RISC-V PLICv1 could be small and simple.

        interrupt-controller@c000000 {
　　　　　　　　　#interrupt-cells = <0x00000001>;
　　　　　　　　　compatible = "riscv,plicv1", "sifive, plic";
　　　　　　　　　interrupt-controller;
　　　　　　　　　interrupts-extended = <0x00000010 0x0000000b 0x00000011 0x0000000b 0x00000011 0x00000009 0x00000012 0x0000000b 0x00000012 0x00000009 0x00000013 0x0000000b 0x00000013 0x00000009 0x00000014 0x0000000b 0x00000014 0x00000009>;	
　　　　　　　　　reg = <0x00000000 0x0c000000 0x00000000 0x04000000>;
　　　　　　　　　reg-names = "control";
        };
	
		
### For the single OS image with the device driver supports RISC-V PLICv1-Compliant PLICs:

In this use case, the Device Tree of RISC-V PLIC is more complex in order to support single OS image and device driver. Below Device Tree takes SiFive PLIC as reference,

        interrupt-controller@c000000 {
　　　　　　　　　#interrupt-cells = <0x00000001>;
　　　　　　　　　compatible = "riscv,plicv1";
　　　　　　　　　interrupt-controller;
　　　　　　　　　interrupts-extended = <0x00000010 0x0000000b 0x00000011 0x0000000b 0x00000011 0x00000009 0x00000012 0x0000000b 0x00000012 0x00000009 0x00000013 0x0000000b 0x00000013 0x00000009 0x00000014 0x0000000b 0x00000014 0x00000009>;	
　　　　　　　　　reg = <0x00000000 0x0c000000 0x00000000 0x04000000>;
　　　　　　　　　reg-names = "control";
　　　　　　　　　riscv,ndev = <0x00000035>;			
　　　　　　　　　riscv,int-context = <&cpu0 0x00000000 "M-Mode">;
　　　　　　　　　riscv,int-context = <&cpu0 0x00000001 "M-Mode">; 
　　　　　　　　　riscv,int-context = <&cpu0 0x00000001 "S-Mode">;
　　　　　　　　　riscv,int-context = <&cpu0 0x00000002 "M-Mode">; 
　　　　　　　　　riscv,int-context = <&cpu0 0x00000002 "S-Mode">; 
　　　　　　　　　riscv,int-context = <&cpu0 0x00000003 "M-Mode">;
　　　　　　　　　riscv,int-context = <&cpu0 0x00000003 "S-Mode">; 
　　　　　　　　　riscv,int-context = <&cpu0 0x00000004 "M-Mode">; 
　　　　　　　　　riscv,int-context = <&cpu0 0x00000004 "S-Mode">; 			
        };		
